---
# subtasks for deploy cluster

- name: ({{ cluster_name }}) Set new instance name in {{ tier.key }}
  ansible.builtin.set_fact:
    instance_name: '{{ instances_on_host[ cnt|int ] }}'
  when: first_deploy == true or tag == 'expand'

- name: ({{ cluster_name }}) Set instance index without autonames in {{ tier.key }}
  ansible.builtin.set_fact:
    instance_index: '{{ cnt|int }}'

- block:
  - block:
    - name: ({{ cluster_name }}) Set existing instance name without autonames in {{ tier.key }}
      ansible.builtin.set_fact:
        instance_name: '{{ (instances_on_host | select ("ansible.builtin.search", tier.key) | list)[instance_id-1] }}'

    - name: ({{ cluster_name }}) Set instance index without autonames in {{ tier.key }}
      ansible.builtin.set_fact:
        instance_index: '{{ instances_on_host.index(instance_name) }}'

    when: autonames == false

  - block:
    - name: ({{ cluster_name }}) Set existing instance with autonames name in {{ tier.key }}
      ansible.builtin.set_fact:
        iname: '{{ (list_instance_names | select ("ansible.builtin.search", tier.key) | list)[instance_id-1] }}'

    - name: ({{ cluster_name }}) Set instance index with autonames in {{ tier.key }}
      ansible.builtin.set_fact:
        instance_index: '{{ list_instance_names.index(iname) }}'

    - name: ({{ cluster_name }}) Set existing instance name with autonames in {{ tier.key }}
      ansible.builtin.set_fact:
        instance_name: '{{ instances_on_host[instance_index|int] }}'

    when: autonames == true
  when: first_deploy == false and tag != 'expand'

- name: ({{ cluster_name }}) Print instance_id and cnt in tier {{ tier.key }}
  ansible.builtin.debug:
    msg: 'instance_id = {{ instance_id }}   cnt = {{ cnt }}   instance_name = {{ instance_name }}   instance_index = {{ instance_index }}'
  run_once: true
  when: debug == true

- name: ({{ cluster_name }}) Create dirs for instance in tier {{ tier.key }}
  ansible.builtin.file:
    name: '{{ data_dir }}/{{ cluster_name }}/{{ instance_name }}'
    state: directory
    owner: '{{ user }}'
    group: '{{ group }}'
    mode: '{{ dir_mode }}'

- name: ({{ cluster_name }}) Generate service-password file in instance dir
  ansible.builtin.copy:
    dest: '{{ data_dir }}/{{ cluster_name }}/{{ instance_name }}/.picodata-cookie'
    content: |
      {{ service_password | default("") }}

    owner: '{{ user }}'
    group: '{{ group }}'
    mode: '0400'

- name: ({{ cluster_name }}) Create links for PG-certs in tier {{ tier.key }}
  ansible.builtin.file:
    src: '{{ cert_dir }}/{{ cluster_name }}/{{ item.filename | basename }}'
    dest: '{{ data_dir }}/{{ cluster_name }}/{{ instance_name }}/{{ item.linkname }}'
    state: link
    owner: '{{ user }}'
    group: '{{ group }}'
  loop:
    - { filename: '{{ cert_file }}', linkname: 'server.crt' }
    - { filename: '{{ key_file }}', linkname: 'server.key' }
    - { filename: '{{ ca_file }}', linkname: 'ca.crt' }
  when: pg_ssl == true

- name: ({{ cluster_name }}) Create config file for instances in tier {{ tier.key }}
  ansible.builtin.template:
    src: instance-conf.j2
    dest: '{{ conf_dir }}/{{ cluster_name }}/{{ instance_name }}.conf'
    owner: '{{ user }}'
    group: '{{ group }}'
  notify:
    - restart
    - refactor

# systemd block
- block:

  # autonames is off
  - block:
    - name: ({{ cluster_name }}) Create dirs for instances in tier {{ tier.key }}
      ansible.builtin.file:
        path: '{{ systemd_dir }}/{{ cluster_name }}@{{ instance_name }}.service.d'
        state: directory

    - name: ({{ cluster_name }}) Create systemd-env file for instances in tier {{ tier.key }}
      ansible.builtin.template:
        src: systemd-unit-env.j2
        dest: '{{ systemd_dir }}/{{ cluster_name }}@{{ instance_name }}.service.d/env.conf'
        force: true
      notify:
        - restart

    - name: ({{ cluster_name }}) Enable systemd services for {{ instance_name }} in tier {{ tier.key }}
      ansible.builtin.systemd:
        name: '{{ cluster_name }}@{{ instance_name }}'
        enabled: true
        state: started
        daemon_reload: true
        scope: '{{ systemd_scope }}'
        force: true
      environment:
        XDG_RUNTIME_DIR: /run/user/{{uid.stdout}}
      register: result

    when: autonames|bool == false

  # autonames is on
  - block:
    - name: ({{ cluster_name }}) Generate template file for systemd
      become: true
      become_user: '{{ systemd_user }}'
      ansible.builtin.template:
        src: systemd-unit-service.j2
        dest: '{{ systemd_dir }}/{{ cluster_name }}-{{ instance_name }}.service'
        force: true
      notify:
        - restart

    - name: ({{ cluster_name }}) Enable systemd services for {{ instance_name }} in tier {{ tier.key }}
      ansible.builtin.systemd:
        name: '{{ cluster_name }}-{{ instance_name }}'
        enabled: true
        state: started
        daemon_reload: true
        scope: '{{ systemd_scope }}'
        force: true
      environment:
        XDG_RUNTIME_DIR: /run/user/{{uid.stdout}}
      register: result

    when: autonames|bool == true

  - name: ({{ cluster_name }}) Check restart if needed
    ansible.builtin.set_fact:
      need_restart: false
    when: result.changed == true

  become: true
  become_user: '{{ systemd_user }}'
  when: init_system == 'systemd'
# end block

- name: ({{ cluster_name }}) Create supervisord conf-files for instances in tier {{ tier.key }}
  ansible.builtin.template:
    src: supervisord-apps.j2
    dest: '{{ supervisord_dir }}/{{ cluster_name }}/{{ instance_name }}.conf'
    force: true
  when: init_system == 'supervisord'
  notify:
    - restart

- name: ({{ cluster_name }}) Calculate next port number on server for all tiers
  ansible.builtin.set_fact:
    cnt: '{{ cnt|int + 1}}'
