# Обслуживание кластера

## Установка кластера

Пример команды:
```bash
ansible-playbook -i hosts.yml picodata.yml
```

> При успешном окончании выполнения плейбука будет создан yaml-файл `report.yml` с перечислением всех инстансов и портов кластера

---

## Удаление кластера

Пример команды:
```bash
ansible-playbook -i hosts.yml picodata.yml -t remove
```

---

## Работа с бэкапами

> Необходимо выставить `backup_dir` в раздел с достаточным количеством свободного места!

> При выставленной переменной `backup_fetch` (по умолчанию `false`) бэкапы будут скачиваться с серверов в каталог, определенный в переменной `backup_fetch_dir`

> При восстановлении (`restore`) кластера используются те же переменные с каталогами, что и для его сохранения (`backup`)

> Если вы используете `rootless` режим, то убедитесь, что удаленному пользователю доступны на чтение каталоги бэкапа, в том числе и вышестоящие!

> Внимание! В версии роли 25.4.4 [для исключения ошибки при восстановлении из бэкапа](https://git.picodata.io/core/picodata/-/issues/2299) для каждого тира нужно указать параметры (можно указать значения по умолчанию):

```yml
memtx:
  memory: 256M
  system_memory: 256M
  max_tuple_size: 1M
vinyl:
  memory: 128M
  cache: 128M
  max_tuple_size: 1M
  page_size: 8K
  range_size: 1G
```

Пример команды для бэкапа кластера:
```bash
ansible-playbook -i hosts.yml picodata.yml -t backup
```

---

Пример команды для восстановления кластера в случае, если кластер уже развернут:
```bash
ansible-playbook -i hosts.yml picodata.yml -t restore
```

---

Пример команды для восстановления кластера на пустых серверах (будет развернут кластер и выполенено восстановление из последнего бэкапа):
```bash
ansible-playbook -i hosts.yml picodata.yml -t restore_full
```

---

Пример команды для восстановления кластера из указанного бэкапа:
```bash
ansible-playbook -i hosts.yml picodata.yml -t restore -e restore_dir=20250716203059
```

> Внимание! Восстановление из последнего бэкапа работает только при выставленной переменной `backup_fetch` в `true` (т.е. когда бэкапы выкачиваются на станцию запуска ansible), в остальных случаях необходимо указывать переменную `restore_dir`!

---
## Перезапуск инстансов кластера

Пример команды для перезапуска всех инстансов кластера:
```bash
ansible-playbook -i hosts.yml picodata.yml -t restart
```

---

## Остановка инстансов кластера

> Например для проведения работ на серверах

Пример команды для остановки всего кластера:
```bash
ansible-playbook -i hosts.yml picodata.yml -t stop
```

Пример команды для остановки всего кластера с отключением systemd служб (службы не будут запускаться автоматически после перезагрузки сервера):
```bash
ansible-playbook -i hosts.yml picodata.yml -t stop -e enable=false
```

---

Пример команды для остановки инстансов на определенном сервере с именем `host` (из указывается из инвентарного файла):
```bash
ansible-playbook -i hosts.yml picodata.yml -t stop -l host
```

---

Пример команды для остановки инстансов на определенном сервере с именем `host` (из указывается из инвентарного файла) с отключением автоматического запуска после рестарта сервера (только для systemd):
```bash
ansible-playbook -i hosts.yml picodata.yml -t stop -e enable=false -l host
```

---

## Запуск инстансов кластера

> Как правило, выполняется после остановки инстансов

Пример команды для запуска всех инстансов кластера:
```bash
ansible-playbook -i hosts.yml picodata.yml -t start
```

---

Пример команды для запуска инстансов на определенном сервере с именем `host` (из указывается из инвентарного файла):
```bash
ansible-playbook -i hosts.yml picodata.yml -t start -l host
```

---

## Работа с плагинами

### Установка и настройка плагина
Пример команды для установки плагинов, указанных в инвентарном файле:
```bash
ansible-playbook -i hosts.yml picodata.yml -t plugins
```

### Обновление версии плагина

Для обновления версии плагина нужно указать путь до новой версии плагина в инвентарном файле, далее запустите роль с тегом `plugins`:
```bash
ansible-playbook -i hosts.yml picodata.yml -t plugins
```

> Откат на предыдущую версию с помощью роли не возможен, для этого используйте SQL-команды

---

## Действия при авариях

> Если вы используете `rootless` режим, то убедитесь, что удаленному пользователю доступны на чтение каталоги бэкапа, в том числе и вышестоящие!

Пример команды для сбора информации после сбоя кластера для отправки ее в техподдержку Пикодаты:
```bash
ansible-playbook -i hosts.yml picodata.yml -t crash_dump
```

Будет собрана вся информация для расследования инцидента. 
После выполнения передать файлы **"*_crash_dump_??????????????.tar.gz"** из каталога `crash_dump_fetch_dir/cluster_name/` (`crash_dump_fetch_dir` и `cluster_name` - переменные из инвентарного файла, если не определены, то используются значения по умолчанию) в техническую поддержку Пикодаты любым доступным способом

> Внимание! В случае проблем с выкачиванием файлов на хост с ansible, файлы будут сохранены в каталоге `backup_dir/cluster_name/crash_dumps/` (`backup_dir` и `cluster_name` - переменные из инвентарного файла, если не определены, то используются значения по умолчанию) на каждом сервере, их можно скачать вручную

> Внимание! На серверах и на станции ansible должно быть достаточно свободного места в разделах, где будут сформированы архивы `crash_dump`

Пример команды для сбора информации **без snap и xlog файлов** после сбоя кластера для отправки ее в техподдержку Пикодаты:
```bash
ansible-playbook -i hosts.yml picodata.yml -t crash_dump -e skipdata=true
```

## Ребутсрап (пересоздание) инсанса

Требуется в случаях, когда репликация сломана и нет возможности отремонтировать вручную

> Работает только на репликасетов с фактором репликации больше 1!!!

Команда для ребутсрапа инстанса с именем `default-3002`
```bash
ansible-playbook -i hosts.yml picodata.yml -t rebootstrap -e instance=default-3002
```

Для работы команды нужен peer-адрес любого инстанса кластера, если он не указан, то будет взят адрес первого инстанса случайного сервера кластера

В случаях, когда адрес первого инстанса случайного сервера кластера совпадает с пересоздаваемым инстансом, его можно указать отдельно через переменную `peer`
```bash
ansible-playbook -i hosts.yml picodata.yml -t rebootstrap -e instance=default-3002 -e peer=192.168.101.168:3302
```

## Обновление кластера

Сейчас в роли нет возможности обновить кластер за один шаг, но можно сделать так:
- указать в инвентарном файле в параметре `picodata_package_path` или `package_with_version` новую версию пакета с пикодатой
- выполнить роль с тегом `install_pkgs` либо обновить пакет с Пикодатой на каждом серевере любым доступным способом
- выполнить роль с тегом `restart` сразу по всем серверам (с простоем) или по очереди (без простоя) через ключ `--limit <server>`

---

## Расширение кластера

### Вертикальное расширение

#### Увеличение ресурсов у инстанса

##### С перезапуском инстансов кластера
- установить в инвентарном файле нужно количество ресурсов, например `memtx_memory` и выполните роль без тега

```bash
ansible-playbook -i hosts.yml picodata.yml
```

при этом обновится конфигурационный файл и **все** инстансы кластера перезапустятся

##### Без перезапуска инстансов кластера

Можно увеличить ресурсы без перезапуска инстансов (можно применить к любым параметрам, которые можно изменять в runtime), для этого:

- выполнить роль с lua-командой по всем инстансам нужного тира для изменения параметра в runtime:
```bash
ansible-playbook -i hosts.yml picodata.yml -t command -e "filter='default'" -e "cmdline='box.cfg{memtx_memory=154217728}'"
```

- для персистентности установить в инвентарном файле параметр `memtx_memory: 154217728` для тира `default` и выполнить роль без тега с переменной, запрещающей перезапуск инстансов кластера:
```bash
ansible-playbook -i hosts.yml picodata.yml -e need_restart=false
```

### Горизонтальное расширение

#### Добавление новых инстансов на те же серверы

- увеличить в инвентарном файле параметры `instance_per_server` или `replicaset_count` у нужных тиров
- выполнить роль с тегом `expand`
```bash
ansible-playbook -i hosts.yml picodata.yml -t expand
```

#### Добавление новых серверов в кластер

> Внимание! Количество серверов должно быть кратным фактору репликации тиров, которые будут находиться на этом сервере!

Шаги:
- добавить новые серверы в инвентарный файл
- выполнить роль без тега
```bash
ansible-playbook -i hosts.yml picodata.yml
```

Возможности и ограничения:

- если нужно одновременно добавить новые серверы и увеличить количество инстансов на каждом из них, то сначала необходимо выполнить пункты из раздела `Добавление новых серверов в кластер`, а затем команды из раздела `Добавление новых инстансов на те же серверы`
- в текущей реализации можно только увеличивать количество инстансов, уменьшить их количество нельзя
- увеличивать количество инстансов можно в любом тире

---

## Прочее

Пример команды для установки пакета `picodata` (если не указана переменная `picodata_package_path`, то на серверах будет подключен репозиторий `picodata`):
```bash
ansible-playbook -i hosts.yml picodata.yml -t install_pkgs
```

Пример команды для получения информации об именах инстансов кластера с их привязкой к серверам:
```bash
ansible-playbook -i hosts.yml picodata.yml -t genin
```

Пример команды для выполнения lua-команды на всех инстансах кластера:
```bash
ansible-playbook -i hosts.yml picodata.yml -t command -e "cmdline='box.slab.info()'"
```

Пример команды для выполнения файла с набором lua-команд на всех инстансах кластера:
```bash
ansible-playbook -i hosts.yml picodata.yml -t command -e "cmdfile='../cmdfile.lua'"
```

Пример команды для выполнения lua-команды на инстансах кластера с именем `default`:
```bash
ansible-playbook -i hosts.yml picodata.yml -t command -e "cmdline='box.slab.info()'" -e "filter='default'"
```

Пример команды для выполнения lua-команды на инстансах кластера, отфильтрованных по условию с использованием регулярного выражения:
```bash
ansible-playbook -i hosts.yml picodata.yml -t command -e "cmdline='box.slab.info()'" -e "filter='.*-2[0-9]{3}'"
```

> Результат выполнения команд будет записан в файл `command_result_??????????????.log` в каталоге, определенном переменной `report_dir`
