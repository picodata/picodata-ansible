---
# tasks for deploy cluster

- name: Print topology
  ansible.builtin.debug:
    msg: "Id: {{ item.key }} Count: {{ item.value.instances_per_server }} Replication factor: {{item.value.replication_factor | default('1')}}"
  loop: "{{ lookup('ansible.builtin.dict', tiers, wantlist=True) }}"
  run_once: true

- name: Check picodata is installed
  ansible.builtin.command:
    cmd: 'picodata --version'
  register: result
  ignore_errors: true

- name: Set flag for install picodata needed
  ansible.builtin.set_fact:
    install_packages: true
  when: result.rc != 0

- name: Unset flag for install picodata if exists
  ansible.builtin.set_fact:
    install_packages: false
  when: result.rc == 0

- name: Install picodata packages
  ansible.builtin.import_tasks:
    file: install_packages.yml
  when: install_packages

- name: Create dirs
  ansible.builtin.file:
    name: '{{ item }}'
    state: directory
    owner: '{{ user }}'
    group: '{{ group }}'
  loop:
    - '{{ conf_dir }}'
    - '{{ log_dir }}'
    - '{{ data_dir }}'
    - '{{ run_dir }}'
    - '{{ conf_dir }}/{{ cluster_id }}'
    - '{{ log_dir }}/{{ cluster_id }}'
    - '{{ data_dir }}/{{ cluster_id }}'
    - '{{ run_dir }}/{{ cluster_id }}'

- name: 'Configure rundir'
  copy:
    content: 'd {{ run_dir }} 0755 {{ user }} {{ group }}'
    dest: '/etc/tmpfiles.d/picodata.conf'
    mode: 0644

- name: Set failure domain
  ansible.builtin.set_fact:
    fd: 'DC={{ group_names }},HOST={{ inventory_hostname }}'
  when: not fd_uniq_per_instance

- name: Debug failure domain
  ansible.builtin.debug:
    msg: 'fd is {{ fd }}'
  when: not fd_uniq_per_instance

- name: Set server failure domain
  ansible.builtin.set_fact:
    host_group: "none"
  when: host_group is undefined

- name: Set peer instance
  ansible.builtin.set_fact:
    main_peer: '{{ listen_address }}'
  run_once: true
  when: main_peer is undefined

- name: Debug main_peer
  ansible.builtin.debug:
    msg: 'main_peer is {{ main_peer }}'
  run_once: true

- name: Generate template file for systemd
  ansible.builtin.template:
    src: systemd-unit-service.j2
    dest: '{{ systemd_dir }}/{{ cluster_id }}@.service'
    force: true
  when: init_system == 'systemd'

- block:
  - name: Create dirs for supervisord
    ansible.builtin.file:
      name: '{{ item }}'
      state: directory
      owner: '{{ user }}'
      group: '{{ group }}'
    loop:
      - '{{ supervisord_dir }}'
      - '{{ supervisord_dir }}/{{ cluster_id }}'

  - name: Generate service unit for supervisord
    ansible.builtin.template:
      src: supervisord-unit-service.j2
      dest: '{{ systemd_dir }}/supervisord-{{ cluster_id }}.service'
      force: true

  - name: Generate cluster config file for supervisord
    ansible.builtin.template:
      owner: '{{ user }}'
      group: '{{ group }}'
      src: supervisord-conf.j2
      dest: '{{ supervisord_dir }}/{{ cluster_id }}.conf'
      force: true

  when: init_system == 'supervisord'
# end block

- name: Generate service-password file
  ansible.builtin.lineinfile:
    path: '{{ conf_dir }}/{{ cluster_id }}/.service-password'
    regexp: '.*'
    line: '{{ service_password }}'
    create: true
    owner: '{{ user }}'
    group: '{{ group }}'
    mode: '0400'    
  when: service_password is defined

- name: Init instance number on server
  ansible.builtin.set_fact:
    instance_num: 0

- name: Tiers setup
  ansible.builtin.include_tasks:
    file: tiers_setup.yml
  loop: "{{ lookup('ansible.builtin.dict', tiers, wantlist=True) }}"
  loop_control:
    loop_var: tier
    extended: true

- block:
  - name: Enable systemd service for supervisord
    ansible.builtin.systemd:
      name: 'supervisord-{{ cluster_id }}.service'
      enabled: true
      state: started
      daemon_reload: true
      force: true
    register: supervisord_service

  - name: Reload systemd service for supervisord if this already started
    ansible.builtin.systemd:
      name: 'supervisord-{{ cluster_id }}.service'
      state: reloaded
    when: supervisord_service.changed == false

  when: init_system == 'supervisord'
# end block

- name: Generate list of instances per server
  ansible.builtin.import_tasks:
    file: genin.yml
  when: admin_password is defined

- name: Wait creating admin-sock files for all instances
  ansible.builtin.wait_for:
    path: '{{ run_dir }}/{{ cluster_id }}/{{ item }}.sock'
    state: present
    msg: 'Timeout to find file {{ run_dir }}/{{ cluster_id }}/{{ item }}.sock'
    timeout: 60
  loop: '{{ instances_on_host }}'

- name: Set admin password
  ansible.builtin.shell:
    cmd: echo "alter user \"admin\" password '{{ admin_password }}' using md5" | picodata admin {{ run_dir }}/{{ cluster_id }}/{{ instances_on_host[0] }}.sock
  when: admin_password is defined
  run_once: true

- name: Set properties for cluster
  ansible.builtin.shell:
    cmd: echo "alter system set \"{{ item.key }}\" = {{ item.value }}" | picodata admin {{ run_dir }}/{{ cluster_id }}/{{ instances_on_host[0] }}.sock
  loop: "{{ lookup('ansible.builtin.dict', property | default({}), wantlist=True) }}"
  run_once: true

- name: Install plugins
  ansible.builtin.include_tasks:
    file: plugins.yml
