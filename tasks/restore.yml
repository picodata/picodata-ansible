---
# tasks for restore:
#   - get list of instances
#   - stop cluster
#   - clean instance name for autonames
#   - clean instance_dir
#   - picodata restore for every instance
#   - start cluster
#   - make links for autonames

# tasks for restore cluster
- name: ({{ cluster_name }}) Set tag variable
  ansible.builtin.set_fact:
    tag: 'restore'

# Set variables for work
- name: ({{ cluster_name }}) Generate list of instances per server
  ansible.builtin.include_tasks:
    file: genin.yml
  when: instances_on_host is not defined

- block:
  - name: ({{ cluster_name }}) Get list of local backups
    become: false
    ansible.builtin.find:
      paths: '{{ backup_fetch_dir }}/{{ cluster_name }}'
      depth: 1
      file_type: directory
      use_regex: yes
      patterns: ['^[0-9]{8}T[0-9]{6}$']
    register: restore_dirs
    run_once: true
    delegate_to: localhost
    when: restore_dir is undefined

  - name: ({{ cluster_name }}) Set backup_dir
    ansible.builtin.set_fact:
      restore_dir: '{{ restore_dirs.files | map(attribute="path") | list | max | basename }}'
      backup_fetch: true
    when: restore_dir is undefined

  - name: ({{ cluster_name }}) Print restore_dir
    debug:
      msg: 'restore_dir: {{ restore_dir }}'

  - name: ({{ cluster_name }}) Check on backup is exists
    ansible.builtin.stat:
      path: '{{ backup_dir }}/{{ cluster_name }}/{{ instances_on_host[0] }}/{{ restore_dir }}'
    register: result

  - block:
    - name: ({{ cluster_name }}) Copy backup archive to remote host
      ansible.builtin.copy:
        src: '{{ backup_fetch_dir }}/{{ cluster_name }}/{{ restore_dir }}/{{ inventory_hostname }}.tar'
        dest: '{{ backup_dir }}/{{ cluster_name }}'
        owner: '{{ user }}'
        group: '{{ group }}'

    - name: ({{ cluster_name }}) Unpack backup
      ansible.builtin.unarchive:
        src: '{{ backup_dir }}/{{ cluster_name }}/{{ inventory_hostname }}.tar'
        dest: '{{ backup_dir }}/{{ cluster_name }}'
        owner: '{{ user }}'
        group: '{{ group }}'
        remote_src: true

    - name: ({{ cluster_name }}) Remove backup archive from remote host
      ansible.builtin.file:
        path: '{{ backup_dir }}/{{ cluster_name }}/{{ inventory_hostname }}.tar'
        state: absent

    when: not result.stat.exists or force_copy_backup == true

  when: backup_fetch == True

# Stop cluster
- name: ({{ cluster_name }}) Stop cluster
  ansible.builtin.include_tasks:
    file: stop.yml

- name: ({{ cluster_name }}) Clear instance name in config file before restore
  ansible.builtin.replace:
    path: '{{ conf_dir }}/{{ cluster_name }}/{{ instance }}.conf'
    regexp: '^  name: '
    replace: '#  name: '
    after: 'instance:'
    before: '  peer: .*'
  loop: '{{ instances_on_host }}'
  loop_control:
    loop_var: instance
  when: autonames == true

# Нужно удалить содержимое в каталоге, а не сам каталог, поэтому rm
- name: ({{ cluster_name }}) Clean instance_dir
  ansible.builtin.shell:
    cmd: 'rm -rf {{ data_dir }}/{{ cluster_name }}/{{ instance }}/*'
  loop: '{{ instances_on_host }}'
  loop_control:
    loop_var: instance

- name: ({{ cluster_name }}) Restore data
  become_user: '{{ systemd_user }}'
  ansible.builtin.command:
    cmd: '{{ bin_dir }}/picodata restore --path {{ backup_dir }}/{{ cluster_name }}/{{ instance }}/{{ restore_dir }} --config {{ conf_dir }}/{{ cluster_name }}/{{ instance }}.conf'
  loop: '{{ instances_on_host }}'
  loop_control:
    loop_var: instance

# picodata restore запускается под become-юзером, поэтому принудительно меняем владельца на файлы
- name: ({{ cluster_name }}) Cange files ownership in instance_dir
  ansible.builtin.file:
    path: '{{ data_dir }}/{{ cluster_name }}/{{ instance }}'
    state: directory
    owner: '{{ user }}'
    group: '{{ group }}'
    recurse: true
  loop: '{{ instances_on_host }}'
  loop_control:
    loop_var: instance

# Start cluster
- name: ({{ cluster_name }}) Start cluster
  ansible.builtin.include_tasks:
    file: start.yml

- name: ({{ cluster_name }}) Wait 30s for build cluster
  ansible.builtin.pause:
    seconds: 30

- name: ({{ cluster_name }}) Wait creating admin-sock files for all instances
  ansible.builtin.wait_for:
    path: '{{ run_dir }}/{{ cluster_name }}/{{ item }}.sock'
    state: present
    msg: 'Ошибка ожидания сокет-файла: {{ run_dir }}/{{ cluster_name }}/{{ item }}.sock! Проверьте логи инстанса!'
    timeout: '{{ timeout_admin_sock }}'
  retries: '{{ retries_admin_sock }}'
  loop: '{{ instances_on_host }}'

- name: ({{ cluster_name }}) Make links for instance name
  ansible.builtin.include_tasks:
    file: make_links.yml
  when: autonames|bool == true

- name: ({{ cluster_name }}) Set flag for create report files
  command: 'true'
  notify:
    - refactor
